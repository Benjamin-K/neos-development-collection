<?php
namespace Neos\Neos\Fusion;

use Neos\ContentRepository\Domain\Context\Dimension;
use Neos\ContentRepository\Domain\Context\DimensionSpace;
use Neos\ContentRepository\Domain\Projection\Content\ContentGraphInterface;
use Neos\ContentRepository\Domain\Projection\Content\ContentSubgraphInterface;
use Neos\ContentRepository\Domain;
use Neos\Flow\Annotations as Flow;
use Neos\ContentRepository\Domain\Model\NodeInterface;

/**
 * Fusion implementation for a dimensions menu.
 *
 * The items generated by this menu will be all possible variants (according to the configured dimensions
 * and presets) of the given node (including the given node).
 *
 * If a 'dimension' is configured via Fusion, only the possible variants for that dimension will
 * be included in the menu, any other dimensions will be kept from the current context.
 *
 * Main Options:
 * - dimension (optional, string): name of the dimension which this menu should be limited to. Example: "language".
 * - presets (optional, array): If set, the presets are not loaded from the Settings, but instead taken from this property. Must be used with "dimension" set.
 */
class DimensionsMenuImplementation extends AbstractMenuImplementation
{
    /**
     * @Flow\Inject
     * @var DimensionSpace\AllowedDimensionSubspace
     */
    protected $allowedDimensionSubspace;

    /**
     * @Flow\Inject
     * @var Dimension\ContentDimensionSourceInterface
     */
    protected $contentDimensionSource;

    /**
     * @Flow\Inject
     * @var DimensionSpace\InterDimensionalVariationGraph
     */
    protected $interDimensionalVariationGraph;

    /**
     * @Flow\Inject
     * @var ContentGraphInterface
     */
    protected $contentGraph;

    /**
     * @return Dimension\ContentDimensionIdentifier|null
     */
    public function getDimension(): ?Dimension\ContentDimensionIdentifier
    {
        return $this->fusionValue('dimension') ? new Dimension\ContentDimensionIdentifier($this->fusionValue('dimension')) : null;
    }

    /**
     * @return array
     */
    public function getPresets(): array
    {
        return $this->fusionValue('presets') ?? [];
    }

    /**
     * @return bool
     */
    public function getIncludeAllPresets(): bool
    {
        return $this->fusionValue('includeAllPresets') ?: false;
    }

    /**
     * Builds the array of Menu items for this variant menu
     */
    protected function buildItems()
    {
        $menuItems = [];

        $currentDimensionSpacePoint = $this->getSubgraph()->getDimensionSpacePoint();
        foreach ($this->allowedDimensionSubspace->getPoints() as $dimensionSpacePoint) {
            if ($this->isDimensionSpacePointRelevant($dimensionSpacePoint)) {
                if ($dimensionSpacePoint->equals($currentDimensionSpacePoint)) {
                    $subgraph = $this->getSubgraph();
                    $variant = $this->currentNode;
                } else {
                    $subgraph = $this->contentGraph->getSubgraphByIdentifier($this->currentNode->getContentStreamIdentifier(), $dimensionSpacePoint);
                    $variant = $subgraph->findNodeByNodeAggregateIdentifier($this->currentNode->getAggregateIdentifier(), $this->currentNode->getContext());
                }

                if (!$variant && $this->getDimension() && $this->getIncludeAllPresets()) {
                    $variant = $this->findClosestGeneralization($dimensionSpacePoint, $this->currentNode->getAggregateIdentifier());
                }

                $metadata = $this->determineMetadata($dimensionSpacePoint);

                /*
                 *
            if ($nodeInDimensions === null && $pinnedDimensionName === null) {
                $itemLabel = '';
                foreach ($targetDimensions as $item) {
                    $itemLabel .= $item['label'] . ' - ';
                }
                $itemLabel = trim($itemLabel, ' -');
            } elseif ($nodeInDimensions instanceof NodeInterface && $pinnedDimensionName === null) {
                $itemLabel = $nodeInDimensions->getLabel();
            } else {
                $itemLabel = $targetDimensions[$pinnedDimensionName]['label'];
            }
                 */
                $menuItems[] = [
                    'subgraph' => $subgraph,
                    'node' => $variant,
                    'state' => $this->calculateItemState($variant),
                    'label' => array_reduce($metadata, function ($carry, $item) {
                        return $carry . (empty($carry) ? '' : '-') . $item['label'];
                    }, ''),
                    'targetDimensions' => $metadata
                ];
            }
        }

        // @todo sort by configured "presets" if present

        return $menuItems;
    }

    /**
     * @param Domain\ValueObject\DimensionSpacePoint $dimensionSpacePoint
     * @return bool
     */
    protected function isDimensionSpacePointRelevant(Domain\ValueObject\DimensionSpacePoint $dimensionSpacePoint): bool
    {
        return !$this->getDimension() // no limit to one dimension, so all DSPs are relevant
            || $dimensionSpacePoint->equals($this->getSubgraph()->getDimensionSpacePoint()) // always include the current variant
            // include all direct variants in the dimension we're limited to unless their values in that dimension are missing in the specified list
            || $dimensionSpacePoint->isDirectVariantInDimension($this->getSubgraph()->getDimensionSpacePoint(), $this->getDimension())
            && (!$this->getPresets() || in_array($dimensionSpacePoint->getCoordinates()[(string)$this->getDimension()], $this->getPresets()));
    }

    /**
     * @param Domain\ValueObject\DimensionSpacePoint $dimensionSpacePoint
     * @param Domain\ValueObject\NodeAggregateIdentifier $nodeAggregateIdentifier
     * @return NodeInterface|null
     */
    protected function findClosestGeneralization(Domain\ValueObject\DimensionSpacePoint $dimensionSpacePoint, Domain\ValueObject\NodeAggregateIdentifier $nodeAggregateIdentifier): ?NodeInterface
    {
        return null;
    }

    /**
     * @param Domain\ValueObject\DimensionSpacePoint $dimensionSpacePoint
     * @return array
     */
    protected function determineMetadata(Domain\ValueObject\DimensionSpacePoint $dimensionSpacePoint): array
    {
        $metadata = $dimensionSpacePoint->getCoordinates();
        array_walk($metadata, function (&$dimensionValue, $rawDimensionIdentifier) {
            $dimensionIdentifier = new Dimension\ContentDimensionIdentifier($rawDimensionIdentifier);
            $dimensionValue = [
                'value' => $dimensionValue,
                'label' => $this->contentDimensionSource->getDimension($dimensionIdentifier)->getValue($dimensionValue)->getConfigurationValue('label'),
                'isPinnedDimension' => (!$this->getDimension() || $dimensionIdentifier->equals($this->getDimension()))
            ];
        });

        return $metadata;
    }

    /**
     * @param NodeInterface|null $variant
     * @return string
     */
    protected function calculateItemState(NodeInterface $variant = null): string
    {
        if (is_null($variant)) {
            return self::STATE_ABSENT;
        }

        if ($variant === $this->currentNode) {
            return self::STATE_CURRENT;
        }

        return self::STATE_NORMAL;
    }

    /**
     * @return ContentSubgraphInterface
     */
    protected function getSubgraph(): ContentSubgraphInterface
    {
        return $this->runtime->getCurrentContext()['subgraph'];
    }
}
